'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var coreAuth = require('@azure/core-auth');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var coreTracing = require('@azure/core-tracing');
var jwt = _interopDefault(require('jsonwebtoken'));
var logger$1 = require('@azure/logger');
var url = require('url');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ClientTokenResponse = {
    type: {
        name: "Composite",
        className: "ClientTokenResponse",
        modelProperties: {
            token: {
                serializedName: "token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            inner: {
                serializedName: "inner",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            inner: {
                serializedName: "inner",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const WebPubSubGenerateClientTokenExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubGenerateClientTokenExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseAllConnectionsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseAllConnectionsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToAllExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToAllExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubConnectionExistsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubConnectionExistsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseConnectionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseConnectionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToConnectionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToConnectionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubGroupExistsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubGroupExistsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseGroupConnectionsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseGroupConnectionsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubAddConnectionToGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubAddConnectionToGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRemoveConnectionFromGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRemoveConnectionFromGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubUserExistsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubUserExistsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCloseUserConnectionsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCloseUserConnectionsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubSendToUserExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubSendToUserExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubAddUserToGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubAddUserToGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRemoveUserFromGroupExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRemoveUserFromGroupExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRemoveUserFromAllGroupsExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRemoveUserFromAllGroupsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubGrantPermissionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubGrantPermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubRevokePermissionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubRevokePermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebPubSubCheckPermissionExceptionHeaders = {
    type: {
        name: "Composite",
        className: "WebPubSubCheckPermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ClientTokenResponse: ClientTokenResponse,
    ErrorDetail: ErrorDetail,
    InnerError: InnerError,
    WebPubSubGenerateClientTokenExceptionHeaders: WebPubSubGenerateClientTokenExceptionHeaders,
    WebPubSubCloseAllConnectionsExceptionHeaders: WebPubSubCloseAllConnectionsExceptionHeaders,
    WebPubSubSendToAllExceptionHeaders: WebPubSubSendToAllExceptionHeaders,
    WebPubSubConnectionExistsExceptionHeaders: WebPubSubConnectionExistsExceptionHeaders,
    WebPubSubCloseConnectionExceptionHeaders: WebPubSubCloseConnectionExceptionHeaders,
    WebPubSubSendToConnectionExceptionHeaders: WebPubSubSendToConnectionExceptionHeaders,
    WebPubSubGroupExistsExceptionHeaders: WebPubSubGroupExistsExceptionHeaders,
    WebPubSubCloseGroupConnectionsExceptionHeaders: WebPubSubCloseGroupConnectionsExceptionHeaders,
    WebPubSubSendToGroupExceptionHeaders: WebPubSubSendToGroupExceptionHeaders,
    WebPubSubAddConnectionToGroupExceptionHeaders: WebPubSubAddConnectionToGroupExceptionHeaders,
    WebPubSubRemoveConnectionFromGroupExceptionHeaders: WebPubSubRemoveConnectionFromGroupExceptionHeaders,
    WebPubSubUserExistsExceptionHeaders: WebPubSubUserExistsExceptionHeaders,
    WebPubSubCloseUserConnectionsExceptionHeaders: WebPubSubCloseUserConnectionsExceptionHeaders,
    WebPubSubSendToUserExceptionHeaders: WebPubSubSendToUserExceptionHeaders,
    WebPubSubAddUserToGroupExceptionHeaders: WebPubSubAddUserToGroupExceptionHeaders,
    WebPubSubRemoveUserFromGroupExceptionHeaders: WebPubSubRemoveUserFromGroupExceptionHeaders,
    WebPubSubRemoveUserFromAllGroupsExceptionHeaders: WebPubSubRemoveUserFromAllGroupsExceptionHeaders,
    WebPubSubGrantPermissionExceptionHeaders: WebPubSubGrantPermissionExceptionHeaders,
    WebPubSubRevokePermissionExceptionHeaders: WebPubSubRevokePermissionExceptionHeaders,
    WebPubSubCheckPermissionExceptionHeaders: WebPubSubCheckPermissionExceptionHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const hub = {
    parameterPath: "hub",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[A-Za-z][A-Za-z0-9_`,.[\\]]{0,127}$")
        },
        serializedName: "hub",
        required: true,
        type: {
            name: "String"
        }
    }
};
const userId = {
    parameterPath: ["options", "userId"],
    mapper: {
        serializedName: "userId",
        type: {
            name: "String"
        }
    }
};
const roles = {
    parameterPath: ["options", "roles"],
    mapper: {
        serializedName: "role",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const expirationTimeInMinutes = {
    parameterPath: ["options", "expirationTimeInMinutes"],
    mapper: {
        defaultValue: 60,
        serializedName: "minutesToExpire",
        type: {
            name: "Number"
        }
    }
};
const excluded = {
    parameterPath: ["options", "excluded"],
    mapper: {
        serializedName: "excluded",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const reason = {
    parameterPath: ["options", "reason"],
    mapper: {
        serializedName: "reason",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: "contentType",
    mapper: {
        serializedName: "Content-Type",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["application/json", "application/octet-stream"]
        }
    }
};
const message = {
    parameterPath: "message",
    mapper: {
        serializedName: "message",
        required: true,
        type: {
            name: "Stream"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: "contentType",
    mapper: {
        defaultValue: "text/plain",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const message1 = {
    parameterPath: "message",
    mapper: {
        serializedName: "message",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const excludedConnections = {
    parameterPath: ["options", "excludedConnections"],
    mapper: {
        serializedName: "excluded",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const connectionId = {
    parameterPath: "connectionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "connectionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const group = {
    parameterPath: "group",
    mapper: {
        constraints: {
            MaxLength: 1024,
            MinLength: 1
        },
        serializedName: "group",
        required: true,
        type: {
            name: "String"
        }
    }
};
const userId1 = {
    parameterPath: "userId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "userId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const permission = {
    parameterPath: "permission",
    mapper: {
        serializedName: "permission",
        required: true,
        type: {
            name: "String"
        }
    }
};
const targetName = {
    parameterPath: ["options", "targetName"],
    mapper: {
        serializedName: "targetName",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing HealthApi operations. */
class HealthApiImpl {
    /**
     * Initialize a new instance of the class HealthApi class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get service health status.
     * @param options The options parameters.
     */
    getServiceStatus(options) {
        return this.client.sendOperationRequest({ options }, getServiceStatusOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getServiceStatusOperationSpec = {
    path: "/api/health",
    httpMethod: "HEAD",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing WebPubSub operations. */
class WebPubSubImpl {
    /**
     * Initialize a new instance of the class WebPubSub class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Generate token for the client to connect Azure Web PubSub service.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param options The options parameters.
     */
    generateClientToken(hub, options) {
        return this.client.sendOperationRequest({ hub, options }, generateClientTokenOperationSpec);
    }
    /**
     * Close the connections in the hub.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param options The options parameters.
     */
    closeAllConnections(hub, options) {
        return this.client.sendOperationRequest({ hub, options }, closeAllConnectionsOperationSpec);
    }
    /**
     * Broadcast content inside request body to all the connected client connections.
     * @param args Includes all the parameters for this operation.
     */
    sendToAll(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[1] === "application/json" ||
            args[1] === "application/octet-stream") {
            operationSpec = sendToAll$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                contentType: args[1],
                message: args[2],
                options: args[3]
            };
            options = args[3];
        }
        else if (args[1] === "text/plain") {
            operationSpec = sendToAll$textOperationSpec;
            operationArguments = {
                hub: args[0],
                contentType: args[1],
                message: args[2],
                options: args[3]
            };
            options = args[3];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Check if the connection with the given connectionId exists.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param connectionId The connection Id.
     * @param options The options parameters.
     */
    connectionExists(hub, connectionId, options) {
        return this.client.sendOperationRequest({ hub, connectionId, options }, connectionExistsOperationSpec);
    }
    /**
     * Close the client connection.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    closeConnection(hub, connectionId, options) {
        return this.client.sendOperationRequest({ hub, connectionId, options }, closeConnectionOperationSpec);
    }
    /**
     * Send content inside request body to the specific connection.
     * @param args Includes all the parameters for this operation.
     */
    sendToConnection(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[2] === "application/json" ||
            args[2] === "application/octet-stream") {
            operationSpec = sendToConnection$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                connectionId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else if (args[2] === "text/plain") {
            operationSpec = sendToConnection$textOperationSpec;
            operationArguments = {
                hub: args[0],
                connectionId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Check if there are any client connections inside the given group
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param options The options parameters.
     */
    groupExists(hub, group, options) {
        return this.client.sendOperationRequest({ hub, group, options }, groupExistsOperationSpec);
    }
    /**
     * Close connections in the specific group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param options The options parameters.
     */
    closeGroupConnections(hub, group, options) {
        return this.client.sendOperationRequest({ hub, group, options }, closeGroupConnectionsOperationSpec);
    }
    /**
     * Send content inside request body to a group of connections.
     * @param args Includes all the parameters for this operation.
     */
    sendToGroup(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[2] === "application/json" ||
            args[2] === "application/octet-stream") {
            operationSpec = sendToGroup$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                group: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else if (args[2] === "text/plain") {
            operationSpec = sendToGroup$textOperationSpec;
            operationArguments = {
                hub: args[0],
                group: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Add a connection to the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param connectionId Target connection Id
     * @param options The options parameters.
     */
    addConnectionToGroup(hub, group, connectionId, options) {
        return this.client.sendOperationRequest({ hub, group, connectionId, options }, addConnectionToGroupOperationSpec);
    }
    /**
     * Remove a connection from the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    removeConnectionFromGroup(hub, group, connectionId, options) {
        return this.client.sendOperationRequest({ hub, group, connectionId, options }, removeConnectionFromGroupOperationSpec);
    }
    /**
     * Check if there are any client connections connected for the given user.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    userExists(hub, userId, options) {
        return this.client.sendOperationRequest({ hub, userId, options }, userExistsOperationSpec);
    }
    /**
     * Close connections for the specific user.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param userId The user Id.
     * @param options The options parameters.
     */
    closeUserConnections(hub, userId, options) {
        return this.client.sendOperationRequest({ hub, userId, options }, closeUserConnectionsOperationSpec);
    }
    /**
     * Send content inside request body to the specific user.
     * @param args Includes all the parameters for this operation.
     */
    sendToUser(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[2] === "application/json" ||
            args[2] === "application/octet-stream") {
            operationSpec = sendToUser$binaryOperationSpec;
            operationArguments = {
                hub: args[0],
                userId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else if (args[2] === "text/plain") {
            operationSpec = sendToUser$textOperationSpec;
            operationArguments = {
                hub: args[0],
                userId: args[1],
                contentType: args[2],
                message: args[3],
                options: args[4]
            };
            options = args[4];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[2]}".`);
        }
        operationArguments.options = options || {};
        return this.client.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Add a user to the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    addUserToGroup(hub, group, userId, options) {
        return this.client.sendOperationRequest({ hub, group, userId, options }, addUserToGroupOperationSpec);
    }
    /**
     * Remove a user from the target group.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param group Target group name, which length should be greater than 0 and less than 1025.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    removeUserFromGroup(hub, group, userId, options) {
        return this.client.sendOperationRequest({ hub, group, userId, options }, removeUserFromGroupOperationSpec);
    }
    /**
     * Remove a user from all groups.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param userId Target user Id.
     * @param options The options parameters.
     */
    removeUserFromAllGroups(hub, userId, options) {
        return this.client.sendOperationRequest({ hub, userId, options }, removeUserFromAllGroupsOperationSpec);
    }
    /**
     * Grant permission to the connection.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    grantPermission(hub, permission, connectionId, options) {
        return this.client.sendOperationRequest({ hub, permission, connectionId, options }, grantPermissionOperationSpec);
    }
    /**
     * Revoke permission for the connection.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    revokePermission(hub, permission, connectionId, options) {
        return this.client.sendOperationRequest({ hub, permission, connectionId, options }, revokePermissionOperationSpec);
    }
    /**
     * Check if a connection has permission to the specified action.
     * @param hub Target hub name, which should start with alphabetic characters and only contain
     *            alpha-numeric characters or underscore.
     * @param permission The permission: current supported actions are joinLeaveGroup and sendToGroup.
     * @param connectionId Target connection Id.
     * @param options The options parameters.
     */
    checkPermission(hub, permission, connectionId, options) {
        return this.client.sendOperationRequest({ hub, permission, connectionId, options }, checkPermissionOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const generateClientTokenOperationSpec = {
    path: "/api/hubs/{hub}/:generateToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClientTokenResponse
        },
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubGenerateClientTokenExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        userId,
        roles,
        expirationTimeInMinutes
    ],
    urlParameters: [endpoint, hub],
    headerParameters: [accept],
    serializer: serializer$1
};
const closeAllConnectionsOperationSpec = {
    path: "/api/hubs/{hub}/:closeConnections",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseAllConnectionsExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        excluded,
        reason
    ],
    urlParameters: [endpoint, hub],
    headerParameters: [accept],
    serializer: serializer$1
};
const sendToAll$binaryOperationSpec = {
    path: "/api/hubs/{hub}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToAllExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [apiVersion, excludedConnections],
    urlParameters: [endpoint, hub],
    headerParameters: [contentType, accept1],
    mediaType: "binary",
    serializer: serializer$1
};
const sendToAll$textOperationSpec = {
    path: "/api/hubs/{hub}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToAllExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [apiVersion, excludedConnections],
    urlParameters: [endpoint, hub],
    headerParameters: [contentType1, accept2],
    mediaType: "text",
    serializer: serializer$1
};
const connectionExistsOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubConnectionExistsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const closeConnectionOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseConnectionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, reason],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const sendToConnection$binaryOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToConnectionExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [contentType, accept1],
    mediaType: "binary",
    serializer: serializer$1
};
const sendToConnection$textOperationSpec = {
    path: "/api/hubs/{hub}/connections/{connectionId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToConnectionExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, connectionId],
    headerParameters: [contentType1, accept2],
    mediaType: "text",
    serializer: serializer$1
};
const groupExistsOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubGroupExistsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, group],
    headerParameters: [accept],
    serializer: serializer$1
};
const closeGroupConnectionsOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/:closeConnections",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseGroupConnectionsExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        excluded,
        reason
    ],
    urlParameters: [endpoint, hub, group],
    headerParameters: [accept],
    serializer: serializer$1
};
const sendToGroup$binaryOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToGroupExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [apiVersion, excludedConnections],
    urlParameters: [endpoint, hub, group],
    headerParameters: [contentType, accept1],
    mediaType: "binary",
    serializer: serializer$1
};
const sendToGroup$textOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToGroupExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [apiVersion, excludedConnections],
    urlParameters: [endpoint, hub, group],
    headerParameters: [contentType1, accept2],
    mediaType: "text",
    serializer: serializer$1
};
const addConnectionToGroupOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/connections/{connectionId}",
    httpMethod: "PUT",
    responses: {
        200: {},
        404: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubAddConnectionToGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        group
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const removeConnectionFromGroupOperationSpec = {
    path: "/api/hubs/{hub}/groups/{group}/connections/{connectionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRemoveConnectionFromGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        group
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const userExistsOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubUserExistsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [accept],
    serializer: serializer$1
};
const closeUserConnectionsOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/:closeConnections",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCloseUserConnectionsExceptionHeaders
        }
    },
    queryParameters: [
        apiVersion,
        excluded,
        reason
    ],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [accept],
    serializer: serializer$1
};
const sendToUser$binaryOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToUserExceptionHeaders
        }
    },
    requestBody: message,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [contentType, accept1],
    mediaType: "binary",
    serializer: serializer$1
};
const sendToUser$textOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/:send",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubSendToUserExceptionHeaders
        }
    },
    requestBody: message1,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [contentType1, accept2],
    mediaType: "text",
    serializer: serializer$1
};
const addUserToGroupOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/groups/{group}",
    httpMethod: "PUT",
    responses: {
        200: {},
        404: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubAddUserToGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        group,
        userId1
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const removeUserFromGroupOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/groups/{group}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRemoveUserFromGroupExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        hub,
        group,
        userId1
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const removeUserFromAllGroupsOperationSpec = {
    path: "/api/hubs/{hub}/users/{userId}/groups",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRemoveUserFromAllGroupsExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, hub, userId1],
    headerParameters: [accept],
    serializer: serializer$1
};
const grantPermissionOperationSpec = {
    path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
    httpMethod: "PUT",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubGrantPermissionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, targetName],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        permission
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const revokePermissionOperationSpec = {
    path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubRevokePermissionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, targetName],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        permission
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const checkPermissionOperationSpec = {
    path: "/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}",
    httpMethod: "HEAD",
    responses: {
        200: {},
        404: {},
        default: {
            bodyMapper: ErrorDetail,
            headersMapper: WebPubSubCheckPermissionExceptionHeaders
        }
    },
    queryParameters: [apiVersion, targetName],
    urlParameters: [
        endpoint,
        hub,
        connectionId,
        permission
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClientContext extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param endpoint HTTP or HTTPS endpoint for the Web PubSub service instance.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-web-pubsub/1.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "{Endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2021-10-01";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint HTTP or HTTPS endpoint for the Web PubSub service instance.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
        this.healthApi = new HealthApiImpl(this);
        this.webPubSub = new WebPubSubImpl(this);
    }
}

// Copyright (c) Microsoft Corporation.
/** @internal */
const createSpan = coreTracing.createSpanFunction({
    namespace: "Microsoft.WebPubSub",
    packagePrefix: "Azure.Messaging.WebPubSub"
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isRequestBody(obj) {
    return (typeof obj === "function" ||
        (typeof obj === "object" &&
            obj != null &&
            (obj.constructor.name === "ArrayBuffer" ||
                obj.constructor.name === "Blob" ||
                ArrayBuffer.isView(obj))));
}
function getPayloadForMessage(message, options) {
    if ((options === null || options === void 0 ? void 0 : options.contentType) === "text/plain") {
        if (typeof message !== "string") {
            throw new TypeError("Message must be a string.");
        }
        return { contentType: "text/plain", payload: message };
    }
    else if (isRequestBody(message)) {
        return { contentType: "application/octet-stream", payload: message };
    }
    else {
        return { contentType: "application/json", payload: JSON.stringify(message) };
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @hidden
 */
class WebPubSubGroupImpl {
    /**
     * @internal
     */
    constructor(client, hubName, groupName) {
        /**
         * The Web PubSub API version being used by this client
         */
        this.apiVersion = "2020-10-01";
        this.client = client;
        this.groupName = groupName;
        this.hubName = hubName;
    }
    /**
     * Add a specific connection to this group
     *
     * @param connectionId - The connection id to add to this group
     * @param options - Additional options
     */
    async addConnection(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-addConnection", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.addConnectionToGroup(this.hubName, this.groupName, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 404) {
                throw new coreRestPipeline.RestError(`Connection id '${connectionId}' doesn't exist`, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Remove a specific connection from this group
     *
     * @param connectionId - The connection id to remove from this group
     * @param options - Additional options
     */
    async removeConnection(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-removeConnection", options);
        try {
            await this.client.webPubSub.removeConnectionFromGroup(this.hubName, this.groupName, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Close all connections to this group
     *
     * @param options - Additional options
     */
    async closeAllConnections(options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-closeAllConnections", options);
        try {
            return await this.client.webPubSub.closeGroupConnections(this.hubName, this.groupName, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Add a user to this group
     *
     * @param username - The user name to add
     * @param options - Additional options
     */
    async addUser(username, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-addUser", options);
        try {
            await this.client.webPubSub.addUserToGroup(this.hubName, this.groupName, username, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Remove a user from this group
     *
     * @param username - The user name to remove
     * @param options - Additional options
     */
    async removeUser(username, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-removeUser", options);
        try {
            await this.client.webPubSub.removeUserFromGroup(this.hubName, this.groupName, username, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    async sendToAll(message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-sendToAll", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            await this.client.webPubSub.sendToGroup(this.hubName, this.groupName, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The programmatic identifier of the webPubSubKeyCredentialPolicy.
 */
const webPubSubKeyCredentialPolicyName = "webPubSubKeyCredentialPolicy";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 * @internal
 */
function webPubSubKeyCredentialPolicy(credential) {
    return {
        name: webPubSubKeyCredentialPolicyName,
        sendRequest(request, next) {
            const bearerToken = jwt.sign({}, credential.key, {
                audience: request.url,
                expiresIn: "1h",
                algorithm: "HS256"
            });
            request.headers.set("Authorization", `Bearer ${bearerToken}`);
            return next(request);
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 */
const logger = logger$1.createClientLogger("web-pubsub");

// Copyright (c) Microsoft Corporation.
function parseConnectionString(conn) {
    const parsed = {};
    conn.split(";").forEach((i) => {
        const assignmentPos = i.indexOf("=");
        if (assignmentPos === -1)
            return;
        const key = i.substring(0, assignmentPos).toLowerCase();
        const value = i.substring(assignmentPos + 1);
        parsed[key] = value;
    });
    let endpointPart = parsed["endpoint"];
    if (!endpointPart)
        throw new TypeError("connection string missing endpoint");
    if (!endpointPart.startsWith("http")) {
        endpointPart = `https://${endpointPart}`;
    }
    const key = parsed["accesskey"];
    if (!key)
        throw new TypeError("connection string missing access key");
    const credential = new coreAuth.AzureKeyCredential(key);
    const port = parsed["port"];
    const url$1 = new url.URL(endpointPart);
    url$1.port = port;
    const endpoint = url$1.toString();
    url$1.port = "";
    return { credential, endpoint };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const webPubSubReverseProxyPolicyName = "webPubSubReverseProxyPolicy";
/**
 * Create an HTTP pipeline policy to use a reverse proxy.
 * This is generally going to be an Azure APIM endpoint.
 * @internal
 */
function webPubSubReverseProxyPolicy(endpoint) {
    const rpEndpointUrl = new URL(endpoint);
    return {
        name: webPubSubReverseProxyPolicyName,
        sendRequest(request, next) {
            const parsedUrl = new URL(request.url);
            parsedUrl.host = rpEndpointUrl.host;
            request.url = parsedUrl.toString();
            return next(request);
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Client for connecting to a Web PubSub hub
 */
class WebPubSubServiceClient {
    constructor(endpointOrConnectionString, credsOrHubName, hubNameOrOpts, opts) {
        var _a, _b;
        /**
         * The Web PubSub API version being used by this client
         */
        this.apiVersion = "2021-10-01";
        // unpack constructor arguments
        if (typeof credsOrHubName === "object") {
            this.endpoint = endpointOrConnectionString;
            this.hubName = hubNameOrOpts;
            this.clientOptions = opts;
            this.credential = credsOrHubName;
        }
        else {
            const parsedCs = parseConnectionString(endpointOrConnectionString);
            this.endpoint = parsedCs.endpoint;
            this.credential = parsedCs.credential;
            this.hubName = credsOrHubName;
            this.clientOptions = hubNameOrOpts;
        }
        const internalPipelineOptions = Object.assign(Object.assign(Object.assign({}, this.clientOptions), {
            apiVersion: this.apiVersion,
            loggingOptions: {
                logger: logger.info
            }
        }), (coreAuth.isTokenCredential(this.credential)
            ? {
                credential: this.credential,
                credentialScopes: ["https://webpubsub.azure.com/.default"]
            }
            : {}));
        this.client = new GeneratedClient(this.endpoint, internalPipelineOptions);
        if (!coreAuth.isTokenCredential(this.credential)) {
            this.client.pipeline.addPolicy(webPubSubKeyCredentialPolicy(this.credential));
        }
        if ((_a = this.clientOptions) === null || _a === void 0 ? void 0 : _a.reverseProxyEndpoint) {
            this.client.pipeline.addPolicy(webPubSubReverseProxyPolicy((_b = this.clientOptions) === null || _b === void 0 ? void 0 : _b.reverseProxyEndpoint));
        }
    }
    /**
     * Get a client for a group
     * @param groupName - The name of the group to connect to.
     */
    group(groupName) {
        return new WebPubSubGroupImpl(this.client, this.hubName, groupName);
    }
    async sendToAll(message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-sendToAll", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            return await this.client.webPubSub.sendToAll(this.hubName, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    async sendToUser(username, message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-sendToUser", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            return await this.client.webPubSub.sendToUser(this.hubName, username, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    async sendToConnection(connectionId, message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-sendToConnection", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            return await this.client.webPubSub.sendToConnection(this.hubName, connectionId, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if a specific connection is connected to this hub
     *
     * @param connectionId - Connection id to check
     * @param options - Additional options
     */
    async connectionExists(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasConnection", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.connectionExists(this.hubName, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Close a specific connection to this hub
     *
     * @param connectionId - Connection id to close
     * @param options - Additional options
     */
    async closeConnection(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-closeConnection", options);
        try {
            return await this.client.webPubSub.closeConnection(this.hubName, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Close all connections to this hub
     *
     * @param options - Additional options
     */
    async closeAllConnections(options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-closeAllConnections", options);
        try {
            return await this.client.webPubSub.closeAllConnections(this.hubName, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Close all connections with the given user id
     *
     * @param user - User id to close
     * @param options - Additional options
     */
    async closeUserConnections(userId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-closeUserConnections", options);
        try {
            return await this.client.webPubSub.closeUserConnections(this.hubName, userId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Remove a specific user from all groups they are joined to
     * @param userId - The user id to remove from all groups
     * @param options - Additional options
     */
    async removeUserFromAllGroups(userId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-removeUserFromAllGroups", options);
        try {
            await this.client.webPubSub.removeUserFromAllGroups(this.hubName, userId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if a particular group exists (i.e. has active connections).
     *
     * @param groupName - The group name to check for
     * @param options - Additional options
     */
    async groupExists(groupName, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasGroup", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.groupExists(this.hubName, groupName, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if a particular user is connected to this hub.
     *
     * @param username - The user name to check for
     * @param options - Additional options
     */
    async userExists(username, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasUser", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.userExists(this.hubName, username, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Grant permissions to a connection
     *
     * @param connectionId - The connection id to grant permissions to
     * @param Permission - The permission to grant
     * @param options - Additional options
     */
    async grantPermission(connectionId, permission, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-grantPermission", options);
        try {
            return await this.client.webPubSub.grantPermission(this.hubName, permission, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Revoke permissions from a connection
     *
     * @param connectionId - The connection id to revoke permissions from
     * @param Permission - The permission to revoke
     * @param options - Additional options
     */
    async revokePermission(connectionId, permission, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-revokePermission", options);
        try {
            return await this.client.webPubSub.revokePermission(this.hubName, permission, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if the connection has the specified permission
     *
     * @param connectionId - The connection id to check permission
     * @param Permission - The permission to check
     * @param options - Additional options
     */
    async hasPermission(connectionId, permission, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasPermission", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.checkPermission(this.hubName, permission, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new coreRestPipeline.RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Generate a token for a client to connect to the Azure Web PubSub service.
     *
     * @param options - Additional options
     */
    async getClientAccessToken(options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-generateClientToken", options);
        try {
            const endpoint = this.endpoint.endsWith("/") ? this.endpoint : this.endpoint + "/";
            const clientEndpoint = endpoint.replace(/(http)(s?:\/\/)/gi, "ws$2");
            const baseUrl = `${clientEndpoint}client/hubs/${this.hubName}`;
            let token;
            if (coreAuth.isTokenCredential(this.credential)) {
                const response = await this.client.webPubSub.generateClientToken(this.hubName, updatedOptions);
                token = response.token;
            }
            else {
                const key = this.credential.key;
                const audience = `${endpoint}client/hubs/${this.hubName}`;
                const payload = { role: options === null || options === void 0 ? void 0 : options.roles };
                const signOptions = {
                    audience: audience,
                    expiresIn: (options === null || options === void 0 ? void 0 : options.expirationTimeInMinutes) === undefined
                        ? "1h"
                        : `${options.expirationTimeInMinutes}m`,
                    algorithm: "HS256"
                };
                if (options === null || options === void 0 ? void 0 : options.userId) {
                    signOptions.subject = options === null || options === void 0 ? void 0 : options.userId;
                }
                token = jwt.sign(payload, key, signOptions);
            }
            return {
                token,
                baseUrl,
                url: `${baseUrl}?access_token=${token}`
            };
        }
        finally {
            span.end();
        }
    }
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.WebPubSubServiceClient = WebPubSubServiceClient;
//# sourceMappingURL=index.js.map
