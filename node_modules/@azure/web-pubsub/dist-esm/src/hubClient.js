// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { RestError } from "@azure/core-rest-pipeline";
import { GeneratedClient } from "./generated/generatedClient";
import { WebPubSubGroupImpl } from "./groupClient";
import { isTokenCredential } from "@azure/core-auth";
import { webPubSubKeyCredentialPolicy } from "./webPubSubCredentialPolicy";
import { createSpan } from "./tracing";
import { logger } from "./logger";
import { parseConnectionString } from "./parseConnectionString";
import jwt from "jsonwebtoken";
import { getPayloadForMessage } from "./utils";
import { webPubSubReverseProxyPolicy } from "./reverseProxyPolicy";
/**
 * Client for connecting to a Web PubSub hub
 */
export class WebPubSubServiceClient {
    constructor(endpointOrConnectionString, credsOrHubName, hubNameOrOpts, opts) {
        var _a, _b;
        /**
         * The Web PubSub API version being used by this client
         */
        this.apiVersion = "2021-10-01";
        // unpack constructor arguments
        if (typeof credsOrHubName === "object") {
            this.endpoint = endpointOrConnectionString;
            this.hubName = hubNameOrOpts;
            this.clientOptions = opts;
            this.credential = credsOrHubName;
        }
        else {
            const parsedCs = parseConnectionString(endpointOrConnectionString);
            this.endpoint = parsedCs.endpoint;
            this.credential = parsedCs.credential;
            this.hubName = credsOrHubName;
            this.clientOptions = hubNameOrOpts;
        }
        const internalPipelineOptions = Object.assign(Object.assign(Object.assign({}, this.clientOptions), {
            apiVersion: this.apiVersion,
            loggingOptions: {
                logger: logger.info
            }
        }), (isTokenCredential(this.credential)
            ? {
                credential: this.credential,
                credentialScopes: ["https://webpubsub.azure.com/.default"]
            }
            : {}));
        this.client = new GeneratedClient(this.endpoint, internalPipelineOptions);
        if (!isTokenCredential(this.credential)) {
            this.client.pipeline.addPolicy(webPubSubKeyCredentialPolicy(this.credential));
        }
        if ((_a = this.clientOptions) === null || _a === void 0 ? void 0 : _a.reverseProxyEndpoint) {
            this.client.pipeline.addPolicy(webPubSubReverseProxyPolicy((_b = this.clientOptions) === null || _b === void 0 ? void 0 : _b.reverseProxyEndpoint));
        }
    }
    /**
     * Get a client for a group
     * @param groupName - The name of the group to connect to.
     */
    group(groupName) {
        return new WebPubSubGroupImpl(this.client, this.hubName, groupName);
    }
    async sendToAll(message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-sendToAll", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            return await this.client.webPubSub.sendToAll(this.hubName, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    async sendToUser(username, message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-sendToUser", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            return await this.client.webPubSub.sendToUser(this.hubName, username, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    async sendToConnection(connectionId, message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-sendToConnection", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            return await this.client.webPubSub.sendToConnection(this.hubName, connectionId, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if a specific connection is connected to this hub
     *
     * @param connectionId - Connection id to check
     * @param options - Additional options
     */
    async connectionExists(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasConnection", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.connectionExists(this.hubName, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Close a specific connection to this hub
     *
     * @param connectionId - Connection id to close
     * @param options - Additional options
     */
    async closeConnection(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-closeConnection", options);
        try {
            return await this.client.webPubSub.closeConnection(this.hubName, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Close all connections to this hub
     *
     * @param options - Additional options
     */
    async closeAllConnections(options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-closeAllConnections", options);
        try {
            return await this.client.webPubSub.closeAllConnections(this.hubName, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Close all connections with the given user id
     *
     * @param user - User id to close
     * @param options - Additional options
     */
    async closeUserConnections(userId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-closeUserConnections", options);
        try {
            return await this.client.webPubSub.closeUserConnections(this.hubName, userId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Remove a specific user from all groups they are joined to
     * @param userId - The user id to remove from all groups
     * @param options - Additional options
     */
    async removeUserFromAllGroups(userId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-removeUserFromAllGroups", options);
        try {
            await this.client.webPubSub.removeUserFromAllGroups(this.hubName, userId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if a particular group exists (i.e. has active connections).
     *
     * @param groupName - The group name to check for
     * @param options - Additional options
     */
    async groupExists(groupName, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasGroup", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.groupExists(this.hubName, groupName, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                throw new RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if a particular user is connected to this hub.
     *
     * @param username - The user name to check for
     * @param options - Additional options
     */
    async userExists(username, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasUser", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.userExists(this.hubName, username, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Grant permissions to a connection
     *
     * @param connectionId - The connection id to grant permissions to
     * @param Permission - The permission to grant
     * @param options - Additional options
     */
    async grantPermission(connectionId, permission, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-grantPermission", options);
        try {
            return await this.client.webPubSub.grantPermission(this.hubName, permission, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Revoke permissions from a connection
     *
     * @param connectionId - The connection id to revoke permissions from
     * @param Permission - The permission to revoke
     * @param options - Additional options
     */
    async revokePermission(connectionId, permission, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-revokePermission", options);
        try {
            return await this.client.webPubSub.revokePermission(this.hubName, permission, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Check if the connection has the specified permission
     *
     * @param connectionId - The connection id to check permission
     * @param Permission - The permission to check
     * @param options - Additional options
     */
    async hasPermission(connectionId, permission, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-hasPermission", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.checkPermission(this.hubName, permission, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 200) {
                return true;
            }
            else if (response.status === 404) {
                return false;
            }
            else {
                // this is sad - wish this was handled by autorest.
                throw new RestError(response.bodyAsText, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Generate a token for a client to connect to the Azure Web PubSub service.
     *
     * @param options - Additional options
     */
    async getClientAccessToken(options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-hub-generateClientToken", options);
        try {
            const endpoint = this.endpoint.endsWith("/") ? this.endpoint : this.endpoint + "/";
            const clientEndpoint = endpoint.replace(/(http)(s?:\/\/)/gi, "ws$2");
            const baseUrl = `${clientEndpoint}client/hubs/${this.hubName}`;
            let token;
            if (isTokenCredential(this.credential)) {
                const response = await this.client.webPubSub.generateClientToken(this.hubName, updatedOptions);
                token = response.token;
            }
            else {
                const key = this.credential.key;
                const audience = `${endpoint}client/hubs/${this.hubName}`;
                const payload = { role: options === null || options === void 0 ? void 0 : options.roles };
                const signOptions = {
                    audience: audience,
                    expiresIn: (options === null || options === void 0 ? void 0 : options.expirationTimeInMinutes) === undefined
                        ? "1h"
                        : `${options.expirationTimeInMinutes}m`,
                    algorithm: "HS256"
                };
                if (options === null || options === void 0 ? void 0 : options.userId) {
                    signOptions.subject = options === null || options === void 0 ? void 0 : options.userId;
                }
                token = jwt.sign(payload, key, signOptions);
            }
            return {
                token,
                baseUrl,
                url: `${baseUrl}?access_token=${token}`
            };
        }
        finally {
            span.end();
        }
    }
}
//# sourceMappingURL=hubClient.js.map