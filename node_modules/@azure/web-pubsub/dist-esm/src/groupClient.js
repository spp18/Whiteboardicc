// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { RestError } from "@azure/core-rest-pipeline";
import { createSpan } from "./tracing";
import { getPayloadForMessage } from "./utils";
/**
 * @hidden
 */
export class WebPubSubGroupImpl {
    /**
     * @internal
     */
    constructor(client, hubName, groupName) {
        /**
         * The Web PubSub API version being used by this client
         */
        this.apiVersion = "2020-10-01";
        this.client = client;
        this.groupName = groupName;
        this.hubName = hubName;
    }
    /**
     * Add a specific connection to this group
     *
     * @param connectionId - The connection id to add to this group
     * @param options - Additional options
     */
    async addConnection(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-addConnection", options);
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (updatedOptions.onResponse) {
                updatedOptions.onResponse(rawResponse, flatResponse);
            }
        }
        try {
            await this.client.webPubSub.addConnectionToGroup(this.hubName, this.groupName, connectionId, Object.assign(Object.assign({}, updatedOptions), { onResponse }));
            if (response.status === 404) {
                throw new RestError(`Connection id '${connectionId}' doesn't exist`, {
                    statusCode: response === null || response === void 0 ? void 0 : response.status,
                    request: response === null || response === void 0 ? void 0 : response.request,
                    response: response
                });
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Remove a specific connection from this group
     *
     * @param connectionId - The connection id to remove from this group
     * @param options - Additional options
     */
    async removeConnection(connectionId, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-removeConnection", options);
        try {
            await this.client.webPubSub.removeConnectionFromGroup(this.hubName, this.groupName, connectionId, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Close all connections to this group
     *
     * @param options - Additional options
     */
    async closeAllConnections(options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-closeAllConnections", options);
        try {
            return await this.client.webPubSub.closeGroupConnections(this.hubName, this.groupName, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Add a user to this group
     *
     * @param username - The user name to add
     * @param options - Additional options
     */
    async addUser(username, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-addUser", options);
        try {
            await this.client.webPubSub.addUserToGroup(this.hubName, this.groupName, username, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    /**
     * Remove a user from this group
     *
     * @param username - The user name to remove
     * @param options - Additional options
     */
    async removeUser(username, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-removeUser", options);
        try {
            await this.client.webPubSub.removeUserFromGroup(this.hubName, this.groupName, username, updatedOptions);
        }
        finally {
            span.end();
        }
    }
    async sendToAll(message, options = {}) {
        const { span, updatedOptions } = createSpan("WebPubSubServiceClient-group-sendToAll", options);
        const { contentType, payload } = getPayloadForMessage(message, updatedOptions);
        try {
            await this.client.webPubSub.sendToGroup(this.hubName, this.groupName, contentType, payload, updatedOptions);
        }
        finally {
            span.end();
        }
    }
}
//# sourceMappingURL=groupClient.js.map